/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-ffmpeg.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : ffmpeg
 #	author : miyako
 #	2019/09/18
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-ffmpeg.h"

#pragma mark -

void OnStartup()
{
    init_dynload();
    
#if CONFIG_AVDEVICE
    avdevice_register_all();
#endif
    avformat_network_init();
}

void OnExit()
{
    
}

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
                
            case kDeinitPlugin :
                OnExit();
                break;
                
			// --- ffmpeg
            
			case 1 :
				ffmpeg_Test(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void free_input_thread(int i, InputFile **input_files) {
    
    InputFile *f = input_files[i];
    AVPacket pkt;
    
    if (!f || !f->in_thread_queue)
        return;
    av_thread_message_queue_set_err_send(f->in_thread_queue, AVERROR_EOF);
    while (av_thread_message_queue_recv(f->in_thread_queue, &pkt, 0) >= 0)
        av_packet_unref(&pkt);
    
    pthread_join(f->thread, NULL);
    f->joined = 1;
    av_thread_message_queue_free(&f->in_thread_queue);
}

void free_input_threads(int nb_input_files, InputFile **input_files) {
    
    int i;
    
    for (i = 0; i < nb_input_files; i++)
        free_input_thread(i, input_files);
}

void init_dynload(void)
{
#ifdef _WIN32
    /* Calling SetDllDirectory with the empty string (but not NULL) removes the
     * current working directory from the DLL search path as a security pre-caution. */
    SetDllDirectory(L"");
#endif
}

static BenchmarkTimeStamps get_benchmark_time_stamps(void)
{
    BenchmarkTimeStamps time_stamps = { av_gettime_relative() };
#if HAVE_GETRUSAGE
    struct rusage rusage;
    
    getrusage(RUSAGE_SELF, &rusage);
    time_stamps.user_usec =
    (rusage.ru_utime.tv_sec * 1000000LL) + rusage.ru_utime.tv_usec;
    time_stamps.sys_usec =
    (rusage.ru_stime.tv_sec * 1000000LL) + rusage.ru_stime.tv_usec;
#elif HAVE_GETPROCESSTIMES
    HANDLE proc;
    FILETIME c, e, k, u;
    proc = GetCurrentProcess();
    GetProcessTimes(proc, &c, &e, &k, &u);
    time_stamps.user_usec =
    ((int64_t)u.dwHighDateTime << 32 | u.dwLowDateTime) / 10;
    time_stamps.sys_usec =
    ((int64_t)k.dwHighDateTime << 32 | k.dwLowDateTime) / 10;
#else
    time_stamps.user_usec = time_stamps.sys_usec = 0;
#endif
    return time_stamps;
}

void ffmpeg_cleanup(FilterGraph **filtergraphs, int nb_filtergraphs, uint8_t *subtitle_out,
                    int nb_output_files, OutputFile **output_files, int nb_output_streams,
                    OutputStream **output_streams, InputStream **input_streams, int nb_input_files,
                    InputFile   **input_files, int nb_input_streams, char *vstats_filename,
                    FILE *vstats_file)
{
    int i, j;
    
    for (i = 0; i < nb_filtergraphs; i++) {
        FilterGraph *fg = filtergraphs[i];
        avfilter_graph_free(&fg->graph);
        for (j = 0; j < fg->nb_inputs; j++) {
            while (av_fifo_size(fg->inputs[j]->frame_queue)) {
                AVFrame *frame;
                av_fifo_generic_read(fg->inputs[j]->frame_queue, &frame,
                                     sizeof(frame), NULL);
                av_frame_free(&frame);
            }
            av_fifo_freep(&fg->inputs[j]->frame_queue);
            if (fg->inputs[j]->ist->sub2video.sub_queue) {
                while (av_fifo_size(fg->inputs[j]->ist->sub2video.sub_queue)) {
                    AVSubtitle sub;
                    av_fifo_generic_read(fg->inputs[j]->ist->sub2video.sub_queue,
                                         &sub, sizeof(sub), NULL);
                    avsubtitle_free(&sub);
                }
                av_fifo_freep(&fg->inputs[j]->ist->sub2video.sub_queue);
            }
            av_buffer_unref(&fg->inputs[j]->hw_frames_ctx);
            av_freep(&fg->inputs[j]->name);
            av_freep(&fg->inputs[j]);
        }
        av_freep(&fg->inputs);
        for (j = 0; j < fg->nb_outputs; j++) {
            av_freep(&fg->outputs[j]->name);
            av_freep(&fg->outputs[j]->formats);
            av_freep(&fg->outputs[j]->channel_layouts);
            av_freep(&fg->outputs[j]->sample_rates);
            av_freep(&fg->outputs[j]);
        }
        av_freep(&fg->outputs);
        av_freep(&fg->graph_desc);
        
        av_freep(&filtergraphs[i]);
    }
    av_freep(&filtergraphs);
    
    av_freep(&subtitle_out);
    
    /* close files */
    for (i = 0; i < nb_output_files; i++) {
        OutputFile *of = output_files[i];
        AVFormatContext *s;
        if (!of)
            continue;
        s = of->ctx;
        if (s && s->oformat && !(s->oformat->flags & AVFMT_NOFILE))
            avio_closep(&s->pb);
        avformat_free_context(s);
        av_dict_free(&of->opts);
        
        av_freep(&output_files[i]);
    }
    for (i = 0; i < nb_output_streams; i++) {
        OutputStream *ost = output_streams[i];
        
        if (!ost)
            continue;
        
        for (j = 0; j < ost->nb_bitstream_filters; j++)
            av_bsf_free(&ost->bsf_ctx[j]);
        av_freep(&ost->bsf_ctx);
        
        av_frame_free(&ost->filtered_frame);
        av_frame_free(&ost->last_frame);
        av_dict_free(&ost->encoder_opts);
        
        av_freep(&ost->forced_keyframes);
        av_expr_free(ost->forced_keyframes_pexpr);
        av_freep(&ost->avfilter);
        av_freep(&ost->logfile_prefix);
        
        av_freep(&ost->audio_channels_map);
        ost->audio_channels_mapped = 0;
        
        av_dict_free(&ost->sws_dict);
        
        avcodec_free_context(&ost->enc_ctx);
        avcodec_parameters_free(&ost->ref_par);
        
        if (ost->muxing_queue) {
            while (av_fifo_size(ost->muxing_queue)) {
                AVPacket pkt;
                av_fifo_generic_read(ost->muxing_queue, &pkt, sizeof(pkt), NULL);
                av_packet_unref(&pkt);
            }
            av_fifo_freep(&ost->muxing_queue);
        }
        
        av_freep(&output_streams[i]);
    }
#if HAVE_THREADS
    free_input_threads(nb_input_files, input_files);
#endif
    for (i = 0; i < nb_input_files; i++) {
        avformat_close_input(&input_files[i]->ctx);
        av_freep(&input_files[i]);
    }
    for (i = 0; i < nb_input_streams; i++) {
        InputStream *ist = input_streams[i];
        
        av_frame_free(&ist->decoded_frame);
        av_frame_free(&ist->filter_frame);
        av_dict_free(&ist->decoder_opts);
        avsubtitle_free(&ist->prev_sub.subtitle);
        av_frame_free(&ist->sub2video.frame);
        av_freep(&ist->filters);
        av_freep(&ist->hwaccel_device);
        av_freep(&ist->dts_buffer);
        
        avcodec_free_context(&ist->dec_ctx);
        
        av_freep(&input_streams[i]);
    }
    
    if (vstats_file) {
		fclose(vstats_file);
    }
    av_freep(&vstats_filename);
    
    av_freep(&input_streams);
    av_freep(&input_files);
    av_freep(&output_streams);
    av_freep(&output_files);
    
    avformat_network_deinit();
}

void ffmpeg_Test(PA_PluginParameters params) {

    BenchmarkTimeStamps ti;
    
    FilterGraph **filtergraphs;
    int        nb_filtergraphs;
    uint8_t *subtitle_out;
    int         nb_output_files   = 0;
    OutputFile   **output_files;
    int         nb_output_streams = 0;
    OutputStream **output_streams = NULL;
    InputStream **input_streams = NULL;
    int        nb_input_files   = 0;
    InputFile   **input_files   = NULL;
    int        nb_input_streams = 0;
    char *vstats_filename;
    FILE *vstats_file;
    
    int run_as_daemon  = 0;
    int nb_frames_dup = 0;
    unsigned dup_warning = 1000;
    int nb_frames_drop = 0;
    int64_t decode_error_stat[2];
    int want_sdp = 1;
    
    /* ffmpeg_parse_options */
    
    BenchmarkTimeStamps current_time = ti = get_benchmark_time_stamps();
    
    /* transcode */
    
    int64_t utime, stime, rtime;
    current_time = get_benchmark_time_stamps();
    utime = current_time.user_usec - ti.user_usec;
    stime = current_time.sys_usec  - ti.sys_usec;
    rtime = current_time.real_usec - ti.real_usec;
}

